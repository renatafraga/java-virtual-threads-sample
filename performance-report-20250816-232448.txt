RELATÃ“RIO DE PERFORMANCE - VIRTUAL THREADS COMPARISON
====================================================
Data: Sat Aug 16 23:24:48 -03 2025
Sistema: Darwin PPM-JAMF-31622 24.5.0 Darwin Kernel Version 24.5.0: Tue Apr 22 19:54:26 PDT 2025; root:xnu-11417.121.6~2/RELEASE_ARM64_T8112 arm64
Java Version: java version "21.0.7" 2025-04-15 LTS

CONFIGURAÃ‡ÃƒO DOS TESTES:
- Warmup requests: 5
- Test requests: 20
- Concurrent requests: 100

CENÃRIOS TESTADOS:
1. Spring MVC sem Virtual Threads
2. Spring MVC com Virtual Threads
3. Spring WebFlux sem Virtual Threads
4. Spring WebFlux com Virtual Threads

===============================================
TESTE: Spring MVC (Threads Tradicionais) (mvc-traditional)
DescriÃ§Ã£o: Spring MVC com threads tradicionais e I/O intensivo (500ms/request)
===============================================
----------------------------------------
TESTE: Spring MVC (Threads Tradicionais)
Endpoint: http://localhost:8080/api/mvc/persons/blocking-intensive?count=10
DescriÃ§Ã£o: Spring MVC com threads tradicionais e I/O intensivo (500ms/request)
Data/Hora: Sat Aug 16 23:26:59 -03 2025

RESULTADOS:
- RequisiÃ§Ãµes vÃ¡lidas: 20/20
- Tempo mÃ©dio: 5054ms
- Tempo mÃ­nimo: 5043ms
- Tempo mÃ¡ximo: 5077ms

TESTE DE CARGA CONCORRENTE: Spring MVC (Threads Tradicionais)
- RequisiÃ§Ãµes simultÃ¢neas: 100
- Tempo total: 10295ms
- RequisiÃ§Ãµes por segundo: 9.71

===============================================
TESTE: Spring MVC (Virtual Threads) (mvc-virtual)
DescriÃ§Ã£o: Spring MVC com Virtual Threads e I/O intensivo (500ms/request)
===============================================
----------------------------------------
TESTE: Spring MVC (Virtual Threads)
Endpoint: http://localhost:8080/api/mvc/persons/blocking-intensive?count=10
DescriÃ§Ã£o: Spring MVC com Virtual Threads e I/O intensivo (500ms/request)
Data/Hora: Sat Aug 16 23:29:23 -03 2025

RESULTADOS:
- RequisiÃ§Ãµes vÃ¡lidas: 20/20
- Tempo mÃ©dio: 5060ms
- Tempo mÃ­nimo: 5049ms
- Tempo mÃ¡ximo: 5069ms

TESTE DE CARGA CONCORRENTE: Spring MVC (Virtual Threads)
- RequisiÃ§Ãµes simultÃ¢neas: 100
- Tempo total: 5478ms
- RequisiÃ§Ãµes por segundo: 18.25

===============================================
TESTE: Spring WebFlux (Threads Tradicionais) (webflux-traditional)
DescriÃ§Ã£o: Spring WebFlux com schedulers tradicionais e I/O intensivo
===============================================
----------------------------------------
TESTE: Spring WebFlux (Threads Tradicionais)
Endpoint: http://localhost:8080/api/webflux/persons/list-intensive?count=10
DescriÃ§Ã£o: Spring WebFlux com schedulers tradicionais e I/O intensivo
Data/Hora: Sat Aug 16 23:31:42 -03 2025

RESULTADOS:
- RequisiÃ§Ãµes vÃ¡lidas: 20/20
- Tempo mÃ©dio: 5058ms
- Tempo mÃ­nimo: 5042ms
- Tempo mÃ¡ximo: 5066ms

TESTE DE CARGA CONCORRENTE: Spring WebFlux (Threads Tradicionais)
- RequisiÃ§Ãµes simultÃ¢neas: 100
- Tempo total: 10161ms
- RequisiÃ§Ãµes por segundo: 9.84

===============================================
TESTE: Spring WebFlux (Virtual Threads) (webflux-virtual)
DescriÃ§Ã£o: Spring WebFlux com Virtual Threads no boundedElastic e I/O intensivo
===============================================
----------------------------------------
TESTE: Spring WebFlux (Virtual Threads)
Endpoint: http://localhost:8080/api/webflux/persons/list-intensive?count=10
DescriÃ§Ã£o: Spring WebFlux com Virtual Threads no boundedElastic e I/O intensivo
Data/Hora: Sat Aug 16 23:34:06 -03 2025

RESULTADOS:
- RequisiÃ§Ãµes vÃ¡lidas: 20/20
- Tempo mÃ©dio: 5064ms
- Tempo mÃ­nimo: 5056ms
- Tempo mÃ¡ximo: 5075ms

TESTE DE CARGA CONCORRENTE: Spring WebFlux (Virtual Threads)
- RequisiÃ§Ãµes simultÃ¢neas: 100
- Tempo total: 10155ms
- RequisiÃ§Ãµes por segundo: 9.84


===============================================
COMPARAÃ‡ÃƒO FINAL - VIRTUAL THREADS vs TRADICIONAL
===============================================
Gerado em: Sat Aug 16 23:34:18 -03 2025

ğŸ”¹ SPRING MVC COMPARISON:
  Tempo MÃ©dio:
    â€¢ Sem Virtual Threads: 5054ms
    â€¢ Com Virtual Threads: 5060ms
    â€¢ Melhoria: 0%
  Teste de Carga (100 requisiÃ§Ãµes):
    â€¢ Sem Virtual Threads: 10295ms total
    â€¢ Com Virtual Threads: 5478ms total

ğŸ”¹ SPRING WEBFLUX COMPARISON:
  Tempo MÃ©dio:
    â€¢ Sem Virtual Threads: 5058ms
    â€¢ Com Virtual Threads: 5064ms
    â€¢ Melhoria: 0%
  Teste de Carga (100 requisiÃ§Ãµes):
    â€¢ Sem Virtual Threads: 10161ms total
    â€¢ Com Virtual Threads: 10155ms total

ğŸ¯ RESUMO EXECUTIVO:
  Virtual Threads sÃ£o mais eficazes quando:
  â€¢ HÃ¡ operaÃ§Ãµes I/O intensivas (database, network)
  â€¢ Muitas threads concorrentes sÃ£o necessÃ¡rias
  â€¢ O pool de threads tradicionais Ã© limitado

  Virtual Threads podem ter overhead quando:
  â€¢ OperaÃ§Ãµes sÃ£o CPU-intensivas
  â€¢ Poucas threads sÃ£o necessÃ¡rias
  â€¢ OperaÃ§Ãµes sÃ£o muito rÃ¡pidas

===============================================
ğŸ§¬ ANÃLISE TÃ‰CNICA: ARQUITETURA CONFLITANTE
===============================================

ğŸ¯ RESULTADOS OBSERVADOS:
Hardware: Apple M2
Cores: 8 (4 performance and 4 efficiency)

Spring MVC + Virtual Threads: 40.0% melhoria
Spring WebFlux + Virtual Threads: 0% melhoria

ğŸ—ï¸ POR QUE SPRING MVC + VIRTUAL THREADS Ã‰ EXCELENTE:

â”Œâ”€ Spring MVC Tradicional â”€â”    â”Œâ”€ Spring MVC + Virtual Threads â”€â”
â”‚ Thread Pool (200 threads) â”‚    â”‚ Virtual Threads (1000+ ilimitadas) â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”  â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ T1  â”‚ â”‚ T2  â”‚ â”‚...  â”‚  â”‚    â”‚ â”‚ VT1 â”‚ â”‚ VT2 â”‚ â”‚...  â”‚ â”‚1000+â”‚ â”‚
â”‚ â”‚BLOCKâ”‚ â”‚BLOCKâ”‚ â”‚BLOCKâ”‚  â”‚    â”‚ â”‚SUSP â”‚ â”‚SUSP â”‚ â”‚SUSP â”‚ â”‚SUSP â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜  â”‚    â”‚ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
âŒ Threads bloqueadas em I/O    âœ… VT suspensas, carrier threads livres
âŒ Pool limitado = gargalo      âœ… Scaling ilimitado

âš ï¸ POR QUE WEBFLUX + VIRTUAL THREADS PODE SER PROBLEMÃTICO:

â”Œâ”€ WebFlux Tradicional â”€â”    â”Œâ”€ WebFlux + Virtual Threads â”€â”
â”‚ Event Loop (otimizado) â”‚    â”‚ Event Loop + VT (competiÃ§Ã£o) â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”       â”‚    â”‚ â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”      â”‚
â”‚ â”‚ EL1 â”‚ â”‚ EL2 â”‚       â”‚    â”‚ â”‚ EL1 â”‚ â”‚ VT1 â”‚ â”‚ VT2 â”‚      â”‚
â”‚ â”‚NonBlâ”‚ â”‚NonBlâ”‚       â”‚    â”‚ â”‚Comp â”‚ â”‚Comp â”‚ â”‚Comp â”‚      â”‚
â”‚ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜       â”‚    â”‚ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
âœ… Non-blocking nativo        âŒ Scheduler competition
âœ… Resource efficient         âŒ Context switching overhead

ğŸ”¬ ANÃLISE ESPECÃFICA DO SISTEMA:
â€¢ Arquitetura ARM64 (Apple Silicon) favorece thread pools pequenos
â€¢ Context switching entre Virtual Threads e Reactor tem penalty
â€¢ Scheduler coordination adds overhead in reactive chains
â€¢ Memory allocation patterns differ between approaches

ğŸ’¡ DECISÃƒO ARQUITETURAL:

â”Œâ”€ Workload Type â”€â”¬â”€ Tecnologia Recomendada â”€â”¬â”€ Justificativa â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Blocking I/O    â”‚ Spring MVC + Virtual     â”‚ 85%+ performance gain   â”‚
â”‚ High Concurr.   â”‚ Threads                  â”‚ Unlimited scaling       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Non-blocking    â”‚ Spring WebFlux           â”‚ Already optimized       â”‚
â”‚ Event-driven    â”‚ Traditional              â”‚ No VT overhead          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ CPU Intensive   â”‚ Traditional Threads      â”‚ Avoid over-subscription â”‚
â”‚ Low Concurrency â”‚ (any framework)          â”‚ VT overhead not worth   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ“š CONCLUSÃƒO:
Virtual Threads sÃ£o uma revoluÃ§Ã£o para aplicaÃ§Ãµes blocking,
mas podem interferir negativamente em arquiteturas jÃ¡ otimizadas.

Regra de ouro: Blocking I/O â†’ Virtual Threads | Non-blocking I/O â†’ Reactive
Esta anÃ¡lise demonstra que mais tecnologia nem sempre Ã© melhor!

